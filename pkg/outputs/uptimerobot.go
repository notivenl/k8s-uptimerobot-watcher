package outputs

import (
	"fmt"
	"strings"

	uptimerobot "github.com/bitfield/uptimerobot/pkg"
	"github.com/notivenl/uptime-kubernetes/pkg/config"
	"github.com/notivenl/uptime-kubernetes/pkg/process"
)

// Uptimerobot is the additional configuration for the uptimerobot output
type UptimerobotConfig struct {
	Uptimerobot_api_token string
}

// UptimeRobot is the output type that sends the data to uptimerobot.com
type Uptimerobot struct {
	client uptimerobot.Client
	config *UptimerobotConfig
}

func init() {
	process.RegisterOutput("uptimerobot", &Uptimerobot{})
}

// Init is called when the output is started
// It loads the additional configuration and creates a new uptimerobot client
func (u *Uptimerobot) Init(config *config.Config) error {
	u.config = &UptimerobotConfig{}
	config.Load(u.config)

	u.client = uptimerobot.New(u.config.Uptimerobot_api_token)

	return nil
}

// Process is called when a new data item is available
// It will search for a monitor with the same name and update it if it exists
// If it doesn't exist it will create a new monitor
func (u *Uptimerobot) Process(data process.Data) {
	if data.Name == "" {
		data.Name = fmt.Sprintf("Autogenerated: %s", data.Url)
	}

	// Search for a monitor with the same domain/path
	monitors, err := u.client.SearchMonitors(
		data.Url,
	)
	if err != nil {
		panic(err)
	}

	// Check if the protocol is https or http
	// If it's http we need to change the url to http
	subtype := uptimerobot.SubTypeHTTPS
	data.Url = "https://" + data.Url
	if data.Protocol == "http" {
		subtype = uptimerobot.SubTypeHTTP
		data.Url = strings.Replace(data.Url, "https", "http", 1)
	}

	monitor := uptimerobot.Monitor{
		FriendlyName: data.Name,
		URL:          data.Url,
		Type:         uptimerobot.TypeHTTP,
		SubType:      subtype,
		Status:       1,
	}

	// Check if the monitor already exists
	if len(monitors) > 0 {
		// Need to place all the new data onto the existing monitor
		m := monitors[0]
		m.FriendlyName = monitor.FriendlyName
		m.URL = monitor.URL
		m.Type = monitor.Type
		m.SubType = monitor.SubType
		m.Status = monitor.Status
		monitor = m

		monitorData, err := monitor.MarshalJSON()
		if err != nil {
			panic(err)
		}

		// Update the existing monitor
		err = u.client.MakeAPICall("editMonitor", nil, monitorData)
		if err != nil {
			panic(err)
		}
		return
	}

	// Create a new monitor
	monitorData, err := monitor.MarshalJSON()
	if err != nil {
		panic(err)
	}

	err = u.client.MakeAPICall("newMonitor", nil, monitorData)
	if err != nil {
		panic(err)
	}
}
